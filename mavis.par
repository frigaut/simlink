// Define gains and other top level parameters
gain_ngs = -0.2*[1,1];
gain_lgs_foc = -0.2;
gain_lgs_fsm = -0.2;
gain_dsm_offload = 0.001;
gain_fsm_offload = 0.05;
gain_ngs_focus_offload = 0.05;
loopfreq = 1000.;
delay = 1;
field = 2*[10,10]; // per window
turb_downlink_rms = 0.13;
turb_uplink_rms = 0.15;
lgsradius = 5.0;
animate_plots = 1;
wrap_series = 0;
pldefault,dpi=120;
nlgs = 8; // works down to 1

if (mavis_config=="simple") {
  nlgs = 1;
  lgsradius = 3.;
  field = 2*[4,5];
}

func prerun(void)
{
  write,format="%s\n","Starting screen capture";
  system,"wf-recorder -g \"12,50 1393x1375\" > /dev/null 2>&1 &";
}

func postrun(void)
{
  pause,1000; 
  system,"pkill --signal SIGINT wf-recorder";
  write,format="%s\n","DONE";
}

prerun = postrun = [];

/**************************************************************/
// SPECIAL EVENTS IN TIME SERIES.
/**************************************************************/
func events(n)
// n is iteration number in main loop() function
{
  extern nodes,delay;
  // change NGS WFS offset at iteration 50:
  // if (n>100) nodes(id_match("ngs_wfs")).offset = [0.,2.0];
  // if (n==100) nodes(id_match("lgs1")).offset += [0.,3.0];
  // if ((n>98)&&(n<108)) delay=-1; else delay=delay_start;
  // if (n>1000) nodes(id_match("ngs_wfs")).offset = [0.,-2.0];
  // nodes(id_match("ngs_wfs")).offset = [0.,2*even(n/1000)];
  // nodes(id_match("ngs_wfs")).offset = [0.,3*(even(round(n/100))-0.5)];
  // if (n>99) delay = 1000;
}

func scenario1(n)
{
  extern nodes,delay;
  extern gain_ngs,gain_lgs_foc,gain_lgs_fsm;
  extern gain_dsm_offload,gain_fsm_offload,gain_ngs_focus_offload;
  if (n==1) {
    write,format="%s\n","Setting all gains to zero";
    gain_ngs=gain_lgs_foc=gain_lgs_fsm=0.;
    gain_dsm_offload=gain_fsm_offload=gain_ngs_focus_offload=0.;
    nodes(id_match("ngs_wfs")).offset = [0,0.0];
    nodes(id_match("ngs_focus_stage")).focpos+=0.2;
    nodes(id_match("sci_objective")).focpos+=0.2;
    nodes.ttpos *= 0;
    nodes(id_match("sci_objective")).ttpos = [2.,2.];
  }
  if (n==1000) {
    write,format="%s\n","Closing NGS loop (TT):\n    gain_ngs=-0.2";
    gain_ngs=-0.2;
  }
  if (n==2000) {
    write,format="%s\n","Closing LGS loop (Focus):\n    gain_lgs_foc=-0.2";
    gain_lgs_foc=-0.2;
  }
  if (n==3000) {
    write,format="%s\n","Closing LGS stabilisation loop (TT âžœ FSM):\n    gain_lgs_fsm=-0.2";
    gain_lgs_fsm=-0.2;
  }
  if (n==4000) {
    write,format="%s\n","Closing DSM offload to telmount:\n    gain_dsm_offload = 0.001";
    gain_dsm_offload = 0.001;
  }
  if (n==5000) {
    write,format="%s\n","Closing FSM offload to LGSF_FM:\n    gain_fsm_offload = 0.05";
    gain_fsm_offload = 0.05;
  }
  if (n==5000) {
    write,format="%s\n","Closing NGS focus control of LGS zoom:\n    gain_ngs_focus_offload = 0.05";
    gain_ngs_focus_offload = 0.05;
  }
  if (n==6000) {
    write,format="%s\n","Offset of NGS (changing ngs offset):\n    nodes(id_match(\"ngs_wfs\")).offset = [0,-2]";
    nodes(id_match("ngs_wfs")).offset = [0,-2.0];
  }
  if (n==7000) {
    write,format="%s\n","Offseting the NGS focus stage (doesn;t exist, but if it did):\n    nodes(id_match(\"ngs_focus_stage\")).focpos+=0.2";
    nodes(id_match("ngs_focus_stage")).focpos+=0.2;
  }
  if (n==8000) {
    write,format="%s\n","Refocusing with science objective (only manual operation):\n    nodes(id_match(\"sci_objective\")).focpos+=0.2";
    nodes(id_match("sci_objective")).focpos+=0.2;
  }
}

events = scenario1;

/**************************************************************/
// DEFINE SYSTEM IN THIS FUNCTION. REFERS TO THE NODE STRUCTURE 
// DEFINITION IN SIMLINK.I
/**************************************************************/
func init_nodes(nit)
{
  extern nodes,idmax,field;
  nodes = [];
  id = 1;

  lgs1off = [3.0,0.];

  // path: 1=science, 2=ngs, 4,8,16=lgs1,2,3...
  scipath = 1;
  ngspath = 2;
  scingspath = scipath+ngspath;
  lgspath = 2^(1+indgen(nlgs));
  alllgspaths = sum(lgspath);
  allpaths = scipath+ngspath+sum(lgspath);

  grow,nodes,node(id=id++,name="ngs",path=scipath+ngspath); // NGS + Science
  for (n=1;n<=nlgs;n++) {
    lgsprefix = swrite(format="lgs%d",n);
    lgsoff = mrot((n-1)*360./nlgs)(+,)*[lgsradius,0.](+);
    grow,nodes,node(id=id++,name=lgsprefix,path=lgspath(n),ttpos=lgsoff,offset=lgsoff,action="lgs",plot=[1,0]); // LGS, including possible offsets
    if (odd(n)) {
      // special treatment for 1LGSF_FM for 2 LGS_FSM:
      path = lgspath(n); if ((n+1)<=nlgs) path += lgspath(n+1);
      grow,nodes,node(id=id++,name=lgsprefix+"f_fm",type="mir",path=path,plot=[1,1]); // LGS launch jitter mirror 
    }
    grow,nodes,node(id=id++,name=lgsprefix+"_uplink",path=lgspath(n),action="lgs_uplink",ts=[turb_uplink_rms,1.],plot=[0,0]); // LGS uplink turb
  }
  grow,nodes,node(id=id++,name="nalayer_alt",path=alllgspaths,action="nalayer_alt",plot=[0,0],fs=[turb_uplink_rms,0.001]);
  grow,nodes,node(id=id++,name="turb",path=allpaths,action="turb",plot=[0,0],ts=[turb_downlink_rms,1.],fs=[turb_uplink_rms,2.]);
  grow,nodes,node(id=id++,name="telmount",path=scipath+ngspath,type="mir",plot=[1,1]); //,freqratio=50); // LGS are installed on the mount, so mount motion doesn't affect them
  grow,nodes,node(id=id++,name="dsm",path=allpaths,action="dsm",type="mir",plot=[1,1]);
  grow,nodes,node(id=id++,name="lgs_focus_stage",path=alllgspaths,type="foc",plot=[1,1]);
  for (n=1;n<=nlgs;n++) {
    lgsprefix = swrite(format="lgs%d",n);
    fsmprefix = swrite(format="lgs%d",(n+1)/2*2-1); // this goes 1,1,3,3,5,5,7,7 for 8 LGS
    lgsoff = mrot((n-1)*360./nlgs)(+,)*[lgsradius,0.](+);
    grow,nodes,node(id=id++,name=lgsprefix+"_fsm",path=lgspath(n),plot=[0,1],action="lgs_fsm",type="mir",action_on=fsmprefix+"f_fm",plot=[1,1]);
    grow,nodes,node(id=id++,name=lgsprefix+"_wfs",path=lgspath(n),type="fp",offset=lgsoff,action="lgs_wfs",action_on=lgsprefix+"_fsm",delay=2,plot=[0,1]);
  }
  grow,nodes,node(id=id++,name="ngs_focus_stage",path=2);
  grow,nodes,node(id=id++,name="ngs_wfs",path=2,action="ngs_wfs",type="fp",delay=2,plot=[0,1]);
  grow,nodes,node(id=id++,name="sci_objective",ttpos=[2.,2.],path=1);
  grow,nodes,node(id=id++,name="imager",path=1,type="fp",plot=[0,1]);

  idmax = id-1; // don't touch this

  // init time series:
  for (i=1;i<=idmax;i++) {
    nodes(i).pos_series = &array(0.,[2,2,nit]);
    nodes(i).poff_series = &array(0.,[2,2,nit]);
    nodes(i).foc_series = &array(0.,nit);
    nodes(i).foff_series = &array(0.,nit);
    if (anyof(nodes(i).ts)) {
      nodes(i).tt_turb_series = &array(0.,[2,2,nit]);
      (*nodes(i).tt_turb_series)(1,) = gen_time_series(nit,nodes(i).ts(1),nodes(i).ts(2));
      (*nodes(i).tt_turb_series)(2,) = gen_time_series(nit,nodes(i).ts(1),nodes(i).ts(2));
    }
    if (anyof(nodes(i).fs)) {
      nodes(i).foc_turb_series = &gen_time_series(nit,nodes(i).fs(1),nodes(i).fs(2));
    }
  }
}

/**************************************************************/
// NODE ACTION FUNCTIONS: TURB, LGS, ETC
/**************************************************************/

func lgs(id,it)
// LGS position
{
  extern nodes;
  // nodes(id).ttpos = (*nodes(id).tt_turb_series)(,it);
  nodes(id).ttpos = nodes(id).offset;
}

func lgs_uplink(id,it)
// effect of uplink turbulence on an LGS
{
  extern nodes;
  // add random walk with spring
  nodes(id).ttpos = (*nodes(id).tt_turb_series)(,it);
}

func turb(id,it)
// effect of turbulence - use PSD-based time series precalculated in init_nodes()
{
  extern nodes;
  // add random walk with spring, in TT:
  nodes(id).ttpos = (*nodes(id).tt_turb_series)(,it);
  nodes(id).focpos = (*nodes(id).foc_turb_series)(it);
}

func nalayer_alt(id,it)
// effect of Na layer altitude on focus
// Use PSD-based time series precalculated in init_nodes()
{
  extern nodes;
  // add random walk with spring, in TT:
  nodes(id).focpos = (*nodes(id).foc_turb_series)(it);
}

func dsm(id,it)
// dsm offload to mount
{
  extern nodes;
  id2 = id_match("telmount");
  if (nodes(id2).freqratio(1)) {
    if ((it%nodes(id2).freqratio(1))!=0) return;
  }
  nodes(id2).ttpos += gain_dsm_offload*nodes(id).ttpos;
}

func ngs_wfs(id,it)
{
  extern nodes;
  // ttpos is the error reported by the ngs wfs
  // let's plug that into the DSM:
  id2 = id_match("dsm");
  // nodes(id2).ttpos += gain_ngs*(nodes(id).ttpos-nodes(id).offset);
  if (nodes(id).delay==0) {
    nodes(id2).ttpos += gain_ngs*(nodes(id).ttpos-nodes(id).offset);
  } else {
    nodes(id2).ttpos += gain_ngs*((*nodes(id).pos_series)(,it-nodes(id).delay)-(*nodes(id).poff_series)(,it-nodes(id).delay));
  }
  // now let's direct focus error toward the LGS zoom
  id2 = id_match("lgs_focus_stage");
  if (nodes(id).delay==0) {
    nodes(id2).focpos += gain_ngs_focus_offload*(nodes(id).focpos-nodes(id).foc_offset);
  } else {
    nodes(id2).focpos += gain_ngs_focus_offload*((*nodes(id).foc_series)(it-nodes(id).delay)-(*nodes(id).foff_series)(it-nodes(id).delay));
  }
}

func lgs_fsm(id,it)
// fsm offload to launch jitter mirror
{
  extern nodes;
  id2 = id_match(nodes(id).action_on);
  // write,nodes(id).name,nodes(id2).name;
  nodes(id2).ttpos += gain_fsm_offload*nodes(id).ttpos;
}

func lgs_wfs(id,it)
{
  extern nodes;
  // correct focus with dsm
  id2 = id_match("dsm");
  nodes(id2).focpos += gain_lgs_foc*nodes(id).focpos;
  // correct tt with LGS FSM
  id2 = id_match(nodes(id).action_on);
  if (nodes(id).delay==0) {
    nodes(id2).ttpos += gain_lgs_fsm*(nodes(id).ttpos-nodes(id).offset);
  } else {
    nodes(id2).ttpos += gain_lgs_fsm*((*nodes(id).pos_series)(,it-nodes(id).delay)-(*nodes(id).poff_series)(,it-nodes(id).delay));
  }
}

