// Define gains and other tp level parameters
if (gain_ngs==[])          gain_ngs = -0.2*[1,1];
if (gain_lgs_foc==[])      gain_lgs_foc = -0.2*0;
if (gain_lgs_fsm==[])      gain_lgs_fsm = -0.2;
if (gain_dsm_offload==[])  gain_dsm_offload = 0.001;
if (gain_fsm_offload==[])  gain_fsm_offload = 0.1;
if (loopfreq==[])          loopfreq = 1000.;
if (delay==[])             delay = 1;
if (field==[])             field = 2*[4,5]; // per window
if (turb_downlink_rms==[]) turb_downlink_rms = 0.13;
if (turb_uplink_rms==[])   turb_uplink_rms = 0.15;
lgsradius = 3.;
animate_plots = 1;

/**************************************************************/
// SPECIAL EVENTS IN TIME SERIES.
/**************************************************************/
func events(n)
// n is iteration number in main loop() function
{
  extern nodes,delay;
  // change NGS WFS offset at iteration 50:
  if (n>100) nodes(id_match("ngs_wfs")).offset = [0.,2.0];
  // if (n==100) nodes(id_match("lgs1")).offset += [0.,3.0];
  // if ((n>98)&&(n<108)) delay=-1; else delay=delay_start;
  // if (n>1000) nodes(id_match("ngs_wfs")).offset = [0.,-2.0];
  // nodes(id_match("ngs_wfs")).offset = [0.,2*even(n/1000)];
  // nodes(id_match("ngs_wfs")).offset = [0.,3*(even(round(n/100))-0.5)];
  // if (n>99) delay = 1000;
}

/**************************************************************/
// DEFINE SYSTEM IN THIS FUNCTION. REFERS TO THE NODE STRUCTURE 
// DEFINITION IN BEAMS.I
/**************************************************************/
func init_nodes(nit)
{
  extern nodes,idmax,field;
  nodes = [];
  id = 1;

  lgs1off = [3.0,0.];

  // path: 1=science, 2=ngs, 4,8,16=lgs1,2,3...
  scipath = 1;
  ngspath = 2;
  scingspath = scipath+ngspath;
  nlgs = 1; // works down to 1
  lgspath = 2^(1+indgen(nlgs));
  allpaths = scipath+ngspath+sum(lgspath);

  grow,nodes,node(id=id++,name="ngs",path=scipath+ngspath); // NGS + Science
  for (n=1;n<=nlgs;n++) {
    lgsprefix = swrite(format="lgs%d",n);
    lgsoff = mrot((n-1)*360./nlgs)(+,)*[lgsradius,0.](+);
    grow,nodes,node(id=id++,name=lgsprefix,path=lgspath(n),ttpos=lgsoff,offset=lgsoff,action="lgs",plot=[1,0]); // LGS, including possible offsets
    if (odd(n)) {
      // special treatment for 1LGSF_FM for 2 LGS_FSM:
      path = lgspath(n); if ((n+1)<=nlgs) path += lgspath(n+1);
      grow,nodes,node(id=id++,name=lgsprefix+"f_fm",type="mir",path=path,plot=[1,1]); // LGS launch jitter mirror 
    }
    grow,nodes,node(id=id++,name=lgsprefix+"_uplink",path=lgspath(n),action="lgs_uplink",ts=[turb_uplink_rms,1.],plot=[0,1]); // LGS uplink turb
  }
  grow,nodes,node(id=id++,name="turb",path=allpaths,action="turb",plot=[0,0],ts=[turb_downlink_rms,1.]);
  grow,nodes,node(id=id++,name="telmount",path=scipath+ngspath,type="mir",plot=[1,1]); //,freqratio=50); // LGS are installed on the mount, so mount motion doesn't affect them
  grow,nodes,node(id=id++,name="dsm",path=allpaths,action="dsm",type="mir",plot=[1,1]);
  grow,nodes,node(id=id++,name="lgs_focus_stage",path=2);
  for (n=1;n<=nlgs;n++) {
    lgsprefix = swrite(format="lgs%d",n);
    fsmprefix = swrite(format="lgs%d",(n+1)/2*2-1); // this goes 1,1,3,3,5,5,7,7 for 8 LGS
    lgsoff = mrot((n-1)*360./nlgs)(+,)*[lgsradius,0.](+);
    grow,nodes,node(id=id++,name=lgsprefix+"_fsm",path=lgspath(n),plot=[0,1],action="lgs_fsm",type="mir",action_on=fsmprefix+"f_fm",plot=[1,1]);
    grow,nodes,node(id=id++,name=lgsprefix+"_wfs",path=lgspath(n),type="fp",offset=lgsoff,action="lgs_wfs",action_on=lgsprefix+"_fsm",delay=2,plot=[0,1]);
  }
  // grow,nodes,node(id=id++,name="ngs_focus_stage",path=1);
  grow,nodes,node(id=id++,name="ngs_wfs",path=1,action="ngs_wfs",type="fp",delay=2,plot=[0,1]);
  // grow,nodes,node(id=id++,name="sci_objective",path=4);
  // grow,nodes,node(id=id++,name="imager",path=4,type="fp");

  idmax = id-1; // don't touch this

  // init time series:
  for (i=1;i<=idmax;i++) {
    nodes(i).pos_series = &array(0.,[2,2,nit]);
    nodes(i).off_series = &array(0.,[2,2,nit]);
    if (anyof(nodes(i).ts)) {
      nodes(i).tseries = &array(0.,[2,2,nit]);
      (*nodes(i).tseries)(1,) = gen_time_series(nit,nodes(i).ts(1),nodes(i).ts(2));
      (*nodes(i).tseries)(2,) = gen_time_series(nit,nodes(i).ts(1),nodes(i).ts(2));
    }
  }
}

/**************************************************************/
// NODE ACTION FUNCTIONS: TURB, LGS, ETC
/**************************************************************/

func lgs(id,it)
// LGS position
{
  extern nodes;
  // nodes(id).ttpos = (*nodes(id).tseries)(,it);
  nodes(id).ttpos = nodes(id).offset;
  // nodes(id).focupdate = (0.0001*random_n()-nodes(id).focpos*0.00001);
  // nodes(id).focpos += nodes(id).focupdate;
}

func lgs_uplink(id,it)
// effect of uplink turbulence on an LGS
{
  extern nodes;
  // add random walk with spring
  nodes(id).ttpos = (*nodes(id).tseries)(,it);
  // nodes(id).ttpos += nodes(id).offset;
  // nodes(id).focupdate = (0.0001*random_n()-nodes(id).focpos*0.00001);
  // nodes(id).focpos += nodes(id).focupdate;
}

func turb(id,it)
// effect of turbulence - use PSD-based time series precalculated in init_nodes()
{
  extern nodes;
  // add random walk with spring, in TT:
  nodes(id).ttpos = (*nodes(id).tseries)(,it);
  // same in focus:
  // nodes(id).focupdate = (0.001*random_n()-nodes(id).focpos*0.0001);
  // nodes(id).focpos += nodes(id).focupdate;
}

func dsm(id,it)
// dsm offload to mount
{
  extern nodes;
  id2 = id_match("telmount");
  if (nodes(id2).freqratio(1)) {
    if ((it%nodes(id2).freqratio(1))!=0) return;
  }
  nodes(id2).ttpos += gain_dsm_offload*nodes(id).ttpos;
}

func ngs_wfs(id,it)
{
  extern nodes;
  // ttpos is the error reported by the ngs wfs
  // let's plug that into the DSM:
  id2 = id_match("dsm");
  // nodes(id2).ttpos += gain_ngs*(nodes(id).ttpos-nodes(id).offset);
  if (nodes(id).delay==0) {
    nodes(id2).ttpos += gain_ngs*(nodes(id).ttpos-nodes(id).offset);
  } else {
    nodes(id2).ttpos += gain_ngs*((*nodes(id).pos_series)(,it-nodes(id).delay)-(*nodes(id).off_series)(,it-nodes(id).delay));
  }
}

func lgs_fsm(id,it)
// fsm offload to launch jitter mirror
{
  extern nodes;
  id2 = id_match(nodes(id).action_on);
  // write,nodes(id).name,nodes(id2).name;
  nodes(id2).ttpos += gain_fsm_offload*nodes(id).ttpos;
}

func lgs_wfs(id,it)
{
  extern nodes;
  // correct focus with dsm
  // id2 = id_match("dsm");
  // nodes(id2).focpos += gain_lgs_foc*nodes(id).focpos;
  // correct tt with LGS FSM
  id2 = id_match(nodes(id).action_on);
  if (nodes(id).delay==0) {
    nodes(id2).ttpos += gain_lgs_fsm*(nodes(id).ttpos-nodes(id).offset);
  } else {
    nodes(id2).ttpos += gain_lgs_fsm*((*nodes(id).pos_series)(,it-nodes(id).delay)-(*nodes(id).off_series)(,it-nodes(id).delay));
  }
}

